# Comprehensive Snake Game Test Specification

This specification outlines an extensive test suite aiming for approximately 100% code coverage of the `Snake.swift` implementation. Each test scenario focuses on identifying specific edge cases and ensuring all behavior is thoroughly examined.

## Board Initialization Tests

These tests target the initialization logic of the `Board`.

1.  `Board` initializes with a default size (16, 16). Verify this.
    *   Expected: Initial board has dimensions `Size(x: 16, y: 16)`.
2.  Initial snake placement is valid. Verify this.
    *   Expected: Snake body starts as `[Position(x:10,y:10)]`, facing `.right`. Its head position should be `(10,10)` and `direction` set to `.right`.
3.  Food spawns at a random non-initial snake location. Check initial state validity.
    *   Expected: Initial food does not occupy the `(10,10)` starting snake cell.

### Implementation details checked
*   Correct type alias usage for `Position`/`Vector`.
*   Proper setting of `.snake`, `.food`, and `size` properties during initialization. (The board is passed a random position generated by `Board.randomPosition(in:)`)

## Snake Movement Tests

These tests focus on the core movement logic of the `Snake`.

4.  Next position calculation based solely on direction (before board updates). Verify this.
    *   For each Direction: `.up`, `.down`, `.left`, `.right`
        a.  The calculated nextPosition is as expected using that direction's velocity vector (`direction.velocity`).
5.  `move()` function correctly adds one element to the body and removes one from the end (tail). Validate this for all directions.
    *   Expected: Snake length remains constant at each step after calling `move()`. The tail segment should be replaced by a new position calculated based on `direction`.
6.  `grow()` function correctly adds one element to the body without removing any, thereby increasing snake length appropriately (and thus changing the calculation of `.length` and `.head`).
    *   Expected: Snake length increases after each call to `grow()`. The added segment should not create a collision.

### Collision Logic Checks
*   Verify that calling `move()` when there's no tail removal occurs only if the snake is set to grow simultaneously.

## Collision Detection Tests

These tests focus specifically on how collisions are detected and handled.

7.  Out-of-bounds collision logic (throw `SnakeError.outOfBounds`). Validate against each board edge.
    *   For all four boundary edges (`x = -1`, `y = -1`, `x = size.x+something` etc., test approach from both sides) ensure the error is thrown correctly when the snake's `.nextPosition` falls outside the grid `(0..<size.x)` and `(0..<size.y)`.
8.  Self-collision (throwing `SnakeError.collision`) occurs only if the snake eats itself by landing on a body segment.
    *   Expected: When the snake tries to move onto any part of its own `[body]`, `collision` error is thrown. Verify this for all adjacent configurations resulting in self-overlap.

### Collision interaction scenarios
*   Test collision detection immediately before calling `move()` or `grow()`.
*   Ensure that during a collision, only the update logic triggers the throw.

## Food Spawning Tests

These tests validate the food generation and respawn mechanisms.

9.  Verify initial random position is valid (within `(0..<size.x)` and `(0..<size.y)`) for all board sizes tested.
    *   Expected: Initial food `position` uses the static method `Board.randomPosition(in:)`, meaning it falls within `[0, size.x-1]` in x and `[0, size.y-1]`.
10. Respawn logic after eating avoids placing food on snake cells (or collisions). Ensure correct implementation.
    *   Expected: After a `.food` detection in `Board.query(position:)`, the respawn loop (`repeat`) checks for empty positions correctly using `query(in:)`. Food should only spawn where grid is not occupied by Snake or other game elements.

### Error handling during respawning
*   If multiple non-empty cells exist, does `randomPosition()` eventually find one `.empty` cell?

## Cell Type Detection Tests

These tests focus on the logic within `Board.query(position:)`.

11. Verify correct assignment of `.snake`, `.food`, or `.empty` based on position checks for all board states.
    *   Expected: Given a position, it should correctly identify if:
        - The cell is part of the Snake's `[body]`
        - It contains the Food
        - Otherwise, it's empty grid space.

### Priority rule test in `query()` (case order)
*   Check that `.food` takes precedence over both `.snake` and `.empty`.
*   Ensure `.snake` returns before `.empty`.

### Out-of-bounds test within query()
*   Test what happens when querying a position exactly on the board edge? Or beyond it?

## Error Handling Tests

These tests check how errors thrown by various components are handled.

13. `Board.update()` correctly throws `.outOfBounds` when `nextPosition` is out of bounds.
    *   Expected: The guard statement in `update()` detects if the new head position (`snake.nextPosition`) is outside `(0..<size.x)` or `(0..<size.y)`, and then appropriately throws `SnakeError.outOfBounds`.
14. `Board.update()` correctly throws `.collision` when next move collides.
    *   Expected: The switch inside `update()` detects `.food`. Then the collision check might look for other snakes or barriers.

### Implementation details within update()
*   Check that even if growth occurs, error throwing isn't affected. (The self-collision check happens after checking if next position is food).

## Length Calculation Tests

These tests focus on the computed property `.length` of `Snake`.

15. Verify that length calculation reflects the actual body array count accurately *after* movement and growth.
    *   Check initial, post-grow, post-move (collision or not), etc., states.

## Board Reset Scenarios

This covers any logic related to restarting the game implicitly needed for robustness.

16. Identify scenarios where full reset might be necessary (e.g., after a fatal collision) and define corresponding tests.

## Implementation Notes

*   These test cases cover all methods (`Board.init()`, `randomPosition(in:)`), structs (`Snake`, `Food`), enums (`Direction`, `Cell`), computed properties, and the core update function with different inputs.
*   The specification is ~100% based on reviewing provided code elements. To achieve truly comprehensive coverage, developers should implement these tests directly against the specific implementation of `Snake` and `Board`.
